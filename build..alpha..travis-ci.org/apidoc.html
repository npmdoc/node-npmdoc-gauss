<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/wayoutmind/gauss#readme"

    >gauss (v0.2.12)</a>
</h1>
<h4>JavaScript statistics, analytics, and set library</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.gauss">module gauss</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gauss.Collection">
            function <span class="apidocSignatureSpan">gauss.</span>Collection
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gauss.TimeSeries">
            function <span class="apidocSignatureSpan">gauss.</span>TimeSeries
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gauss.Vector">
            function <span class="apidocSignatureSpan">gauss.</span>Vector
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>gauss</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gauss.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gauss.Collection">module gauss.Collection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gauss.Collection.Collection">
            function <span class="apidocSignatureSpan">gauss.</span>Collection
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gauss.TimeSeries">module gauss.TimeSeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gauss.TimeSeries.TimeSeries">
            function <span class="apidocSignatureSpan">gauss.</span>TimeSeries
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gauss.Vector">module gauss.Vector</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gauss.Vector.Vector">
            function <span class="apidocSignatureSpan">gauss.</span>Vector
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gauss.gauss">module gauss.gauss</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gauss.gauss.Collection">
            function <span class="apidocSignatureSpan">gauss.gauss.</span>Collection
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gauss.gauss.TimeSeries">
            function <span class="apidocSignatureSpan">gauss.gauss.</span>TimeSeries
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gauss.gauss.Vector">
            function <span class="apidocSignatureSpan">gauss.gauss.</span>Vector
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">gauss.gauss.</span>version</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gauss" id="apidoc.module.gauss">module gauss</a></h1>


    <h2>
        <a href="#apidoc.element.gauss.Collection" id="apidoc.element.gauss.Collection">
        function <span class="apidocSignatureSpan">gauss.</span>Collection
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Collection = function (values) {
  &#x22;use strict&#x22;;
  var collection = Array.isArray(values) ?
    values :
    Array.prototype.slice.call(arguments);

  if (Array.prototype.slice.call(arguments).length === 0) {
    collection = [];
  }

  var result = function(value, callback) {
    if (callback) {
      return callback(value);
    }
    else {
      return value;
    }
  };

  Object.defineProperty(collection, &#x27;extend&#x27;, {
<span class="apidocCodeCommentSpan">    /**
     * Return a Collection extended with named functions.
     * @param methods Object { &#x27;functionName&#x27;: function() {} }
     */
</span>    value: function(methods, callback) {
      for (var method in methods) {
        Object.defineProperty(this, method, {
          value: methods[method],
          writable: true,
          enumerable: false
        });
      }
      return result(this, callback);
    },
    writable: true,
    enumerable: false
  });

  collection.extend({
    indexOf: function(element, callback) {
      var index = -1;
      for (var i = 0; i &#x3c; this.length; i++) {
        if (this[i] === element) {
          index = i;
          break;
        }
      }
      return result(index, callback);
    },
    /**
     * Returns the first index of an element that matches a condition.
     * @param predicate {Function}
     * @param callback {Function}
     */
    indexBy: function(predicate, callback) {
      var index = -1;
      for (var i = 0; i &#x3c; this.length; i++) {
        if (predicate(this[i])) {
          index = i;
          break;
        }
      }
      return result(index, callback);
    },
    /**
     * Returns the indices of all elements that match a value.
     * @param element {Object}
     * @param callback {Function}
     */
    indicesOf: function(element, callback) {
      var start = this.indexOf(element),
          end = this.lastIndexOf(element),
          indices = new Collection();
      if (start === end) {
        indices.push(start);
      }
      else {
        for (var i = start; i &#x3c;= end; i++) {
          if (this[i] === element) {
            indices.push(i);
          }
        }
      }
      return result(indices, callback);
    },
    /**
     * Returns all indices of an element that match a condition.
     * @param predicate {Function}
     * @param callback {Function}
     */
    indicesBy: function(predicate, callback) {
      var start = 0,
          end = this.length - 1,
          indices = new Collection();
      if (start === end) {
        indices.push(start);
      }
      else {
        for (var i = start; i &#x3c;= end; i++) {
          if (predicate(this[i])) {
            indices.push(i);
          }
        }
      }
      return result(indices, callback);
    },
    /**
     * Returns the last index of an element that matches a condition.
     * @param predicate {Function}
     * @param callback {Function}
     */
    lastIndexBy: function(predicate, callback) {
      var index = -1;
      for (var i = this.length - 1; i &#x3e;= 0; i--) {
        if (predicate(this[i])) {
          index = i;
          break;
        }
      }
      return result(index, callback);
    },
    /**
     * Returns all the elements that match a condition.
     * @param predicate {Function or Object}
     * @param callback {Function}
     */
    find: function(predicate, callback) {
      var results = new Collection(),
          comparator = function(e) { return e === true; };
      if (typeof predicate === &#x27;object&#x27;) {
        for (var i = 0; i &#x3c; this.length; i++) {
          var conditions = [];
          for (var key in predicate) {
            conditions.push(predicate[key] === this[i][key]);
          }
          if (conditions.every(comparator)) {
            results.push(this[i]);
          }
        }
      } else {
        for (var i = 0; i &#x3c; this.length; i++) {
          if (predicate(this[i])) {
            results.push(this[i]);
          }
        }
      }
      return result(results, callback);
    },
    /**
     * Returns the first element that matches a condition.
     * @param predicate {Function or Object}
     * @param callback {Function}
     */
    findOne: fun ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Collection.find

    .find(predicate, callback)

Returns all the elements that match a condition.

``` javascript
var people = new gauss.<span class="apidocCodeKeywordSpan">Collection</span>(
  { firstname: &#x27;John&#x27;, lastname: &#x27;Smith&#x27; },
  { firstname: &#x27;Jane&#x27;, lastname: &#x27;Doe&#x27; },
  { firstname: &#x27;Mike&#x27;, lastname: &#x27;Smith&#x27; },
  { firstname: &#x27;Susan&#x27;, lastname: &#x27;Baker&#x27; }
);
// Using a predicate Function
people.find(function(e) { return e.firstname === &#x27;Jane&#x27; });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gauss.TimeSeries" id="apidoc.element.gauss.TimeSeries">
        function <span class="apidocSignatureSpan">gauss.</span>TimeSeries
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TimeSeries = function (values) {
  &#x22;use strict&#x22;;
  var timeseries = (arguments.length === 2) ?
    Array.prototype.slice.call(arguments) :
    values;

  if (Array.prototype.slice.call(arguments).length === 0) {
    timeseries = [];
  }

  var result = function(value, callback) {
    if (callback) {
      return callback(value);
    }
    else {
      return value;
    }
  };

  Object.defineProperty(timeseries, &#x27;extend&#x27;, {
<span class="apidocCodeCommentSpan">    /**
     * Return a TimeSeries extended with named functions.
     * @param methods Object { &#x27;functionName&#x27;: function() {} }
     */
</span>    value: function(methods, callback) {
      Collection.extend.bind(this);
      return Collection.extend.apply(this, arguments);
    },
    writable: true,
    enumerable: false
  });

  timeseries.extend({
    byValue: function(a, b) {
      return ((a[1] &#x3c; b[1]) ? -1 : ((a[1] &#x3e; b[1]) ? 1 : 0));
    },
    byDate: function(a, b) {
      return ((a[0] &#x3c; b[0]) ? -1 : ((a[0] &#x3e; b[0]) ? 1 : 0));
    },
    times: function(callback) {
      var times = new Vector(Array.prototype.map.call(this, function(i) {
        return i[0];
      }));
      return result(times, callback);
    },
    values: function(callback) {
      var values = new Vector(Array.prototype.map.call(this, function(i) {
        return i[1];
      }));
      return result(values, callback);
    }
  });

  timeseries.extend({
    every: Collection.every,
    append: Collection.append
  });

  return timeseries;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

*Deprecated*

Perform time series analysis. TimeSeries currently accepts time in epoch milliseconds followed by a numeric value.

``` javascript
var gauss = require(&#x27;gauss&#x27;);
var set = new gauss.<span class="apidocCodeKeywordSpan">TimeSeries</span>([1315378833000, 3.5], [1315789015000, 7.826]);
```

#### TimeSeries.times

    .times(callback)

Returns a Vector of the times.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gauss.Vector" id="apidoc.element.gauss.Vector">
        function <span class="apidocSignatureSpan">gauss.</span>Vector
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Vector = function (values) {
  &#x22;use strict&#x22;;
  var vector = Array.isArray(values) ?
    values :
    Array.prototype.slice.call(arguments);

  if (Array.prototype.slice.call(arguments).length === 0) {
    vector = [];
  }

  // Initialize vector cache
  var cache = {
    sum: 0.0,
    product: 1.0,
    variance: 0.0,
    sample: {
      variance: 0.0
    },
    values: Array.prototype.slice.call(vector)
  };

  cache.sync = function() {
    cache.values = Array.prototype.slice.call(vector);
  };

  // Sorting primatives
  var asc = function(a, b) {
    return a - b;
  };

  var extend = function(value, callback) {
    value = Array.isArray(value) ?
      new Vector(value) : value;
    if (callback) {
      return callback(value);
    }
    else {
      return value;
    }
  };

  var result = function(value, callback) {
    if (callback) {
      return callback(value);
    }
    else {
      return value;
    }
  };

  Object.defineProperty(vector, &#x27;extend&#x27;, {
<span class="apidocCodeCommentSpan">    /**
     * Return a Vector extended with named functions.
     * @param methods Object { &#x27;functionName&#x27;: function() {} }
     */
</span>    value: function(methods, callback) {
      Collection.extend.bind(this);
      return Collection.extend.apply(this, arguments);
    },
    writable: true,
    enumerable: false
  });

  vector.extend({
    indexOf: Collection.indexOf,
    indexBy: Collection.indexBy,
    indicesOf: function(element, callback) {
      return extend(Collection.indicesOf.apply(this, arguments), callback);
    },
    indicesBy: function(predicate, callback) {
      return extend(Collection.indicesBy.apply(this, arguments), callback);
    },
    lastIndexBy: function(predicate, callback) {
      return extend(Collection.lastIndexBy.apply(this, arguments), callback);
    },
    find: function(predicate, callback) {
      return extend(Collection.find.apply(this, arguments), callback);
    },
    findOne: function(predicate, callback) {
      return extend(Collection.findOne.apply(this, arguments), callback);
    },
    mode: function(callback) {
      return extend(Collection.mode.apply(this), callback);
    },
    frequency: Collection.frequency,
    distribution: Collection.distribution,
    append: Collection.append,
    equal: Collection.equal,
    clone: function(callback) {
      return extend(Collection.clone.apply(this), callback);
    },
    copy: function(callback) {
      return extend(Collection.copy.apply(this), callback);
    },
    toArray: Collection.toArray,
    /**
     * [Accessor methods]
     */
    concat: function() {
      var args = Array.prototype.slice.call(arguments);
      var end = args[args.length - 1];
      if (typeof end === &#x27;function&#x27;) {
        return extend(Collection.concat.apply(this, arguments), end);
      }
      else {
        return extend(Collection.concat.apply(this, arguments));
      }
    },
    slice: function(begin, end, callback) {
      return extend(Collection.slice.apply(this, arguments), callback);
    },
    split: function(predicate, callback) {
      return extend(Collection.split.apply(this, arguments), callback);
    },
    unique: function(callback) {
      return extend(Collection.unique.apply(this), callback);
    },
    /**
     * [Iteration methods]
     */
    filter: function(callback, next) {
      return extend(Collection.filter.apply(this, arguments), next);
    },
    every: Collection.every,
    map: function(callback, next) {
      return extend(Collection.map.apply(this, arguments), next);
    },
    some: Collection.some,
    reduce: function(callback, initialValue, next) {
      return extend(Collection.reduce.apply(this, arguments), next);
    },
    reduceRight: function(callback, initialValue, next) {
      return extend(Collection.reduceRight.apply(this, arguments), next);
    },
    union: function(that, callback) {
      return extend(Collection.union.apply(this, arguments), callback);
    },
    sum: function(callback) {
      var sum = 0.0;
      if (this.equal(cache.values) &#x26;&#x26; cache.sum !== 0.0) {
        sum = cache.sum;
      }
      else {
        for (var i = 0; i &#x3c; this.le ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Gauss requires support for ECMAScript 5 `Object.defineProperty`. Compatibility is listed [here](http://kangax.github.com/es5-compat
-table/). Download and include [gauss.min.js](https://raw.github.com/wayoutmind/gauss/master/gauss.min.js):

``` html
&#x3c;script src=&#x22;gauss.min.js&#x22; type=&#x22;text/javascript&#x22;&#x3e;&#x3c;/script&#x3e;
&#x3c;script type=&#x22;text/javascript&#x22; charset=&#x22;utf-8&#x22;&#x3e;
var Vector = gauss.Vector,
    TimeSeries = gauss.TimeSeries;
var set = new gauss.<span class="apidocCodeKeywordSpan">Vector</span>(5, 1, 3, 2, 21),
    numbers = new Vector([8, 6, 7, 5, 3, 0, 9]);
&#x3c;/script&#x3e;
```

The [Bower](http://bower.io/) package manager can also be used to install Gauss:

$ bower install gauss
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gauss.Collection" id="apidoc.module.gauss.Collection">module gauss.Collection</a></h1>


    <h2>
        <a href="#apidoc.element.gauss.Collection.Collection" id="apidoc.element.gauss.Collection.Collection">
        function <span class="apidocSignatureSpan">gauss.</span>Collection
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Collection = function (values) {
  &#x22;use strict&#x22;;
  var collection = Array.isArray(values) ?
    values :
    Array.prototype.slice.call(arguments);

  if (Array.prototype.slice.call(arguments).length === 0) {
    collection = [];
  }

  var result = function(value, callback) {
    if (callback) {
      return callback(value);
    }
    else {
      return value;
    }
  };

  Object.defineProperty(collection, &#x27;extend&#x27;, {
<span class="apidocCodeCommentSpan">    /**
     * Return a Collection extended with named functions.
     * @param methods Object { &#x27;functionName&#x27;: function() {} }
     */
</span>    value: function(methods, callback) {
      for (var method in methods) {
        Object.defineProperty(this, method, {
          value: methods[method],
          writable: true,
          enumerable: false
        });
      }
      return result(this, callback);
    },
    writable: true,
    enumerable: false
  });

  collection.extend({
    indexOf: function(element, callback) {
      var index = -1;
      for (var i = 0; i &#x3c; this.length; i++) {
        if (this[i] === element) {
          index = i;
          break;
        }
      }
      return result(index, callback);
    },
    /**
     * Returns the first index of an element that matches a condition.
     * @param predicate {Function}
     * @param callback {Function}
     */
    indexBy: function(predicate, callback) {
      var index = -1;
      for (var i = 0; i &#x3c; this.length; i++) {
        if (predicate(this[i])) {
          index = i;
          break;
        }
      }
      return result(index, callback);
    },
    /**
     * Returns the indices of all elements that match a value.
     * @param element {Object}
     * @param callback {Function}
     */
    indicesOf: function(element, callback) {
      var start = this.indexOf(element),
          end = this.lastIndexOf(element),
          indices = new Collection();
      if (start === end) {
        indices.push(start);
      }
      else {
        for (var i = start; i &#x3c;= end; i++) {
          if (this[i] === element) {
            indices.push(i);
          }
        }
      }
      return result(indices, callback);
    },
    /**
     * Returns all indices of an element that match a condition.
     * @param predicate {Function}
     * @param callback {Function}
     */
    indicesBy: function(predicate, callback) {
      var start = 0,
          end = this.length - 1,
          indices = new Collection();
      if (start === end) {
        indices.push(start);
      }
      else {
        for (var i = start; i &#x3c;= end; i++) {
          if (predicate(this[i])) {
            indices.push(i);
          }
        }
      }
      return result(indices, callback);
    },
    /**
     * Returns the last index of an element that matches a condition.
     * @param predicate {Function}
     * @param callback {Function}
     */
    lastIndexBy: function(predicate, callback) {
      var index = -1;
      for (var i = this.length - 1; i &#x3e;= 0; i--) {
        if (predicate(this[i])) {
          index = i;
          break;
        }
      }
      return result(index, callback);
    },
    /**
     * Returns all the elements that match a condition.
     * @param predicate {Function or Object}
     * @param callback {Function}
     */
    find: function(predicate, callback) {
      var results = new Collection(),
          comparator = function(e) { return e === true; };
      if (typeof predicate === &#x27;object&#x27;) {
        for (var i = 0; i &#x3c; this.length; i++) {
          var conditions = [];
          for (var key in predicate) {
            conditions.push(predicate[key] === this[i][key]);
          }
          if (conditions.every(comparator)) {
            results.push(this[i]);
          }
        }
      } else {
        for (var i = 0; i &#x3c; this.length; i++) {
          if (predicate(this[i])) {
            results.push(this[i]);
          }
        }
      }
      return result(results, callback);
    },
    /**
     * Returns the first element that matches a condition.
     * @param predicate {Function or Object}
     * @param callback {Function}
     */
    findOne: fun ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Collection.find

    .find(predicate, callback)

Returns all the elements that match a condition.

``` javascript
var people = new gauss.<span class="apidocCodeKeywordSpan">Collection</span>(
  { firstname: &#x27;John&#x27;, lastname: &#x27;Smith&#x27; },
  { firstname: &#x27;Jane&#x27;, lastname: &#x27;Doe&#x27; },
  { firstname: &#x27;Mike&#x27;, lastname: &#x27;Smith&#x27; },
  { firstname: &#x27;Susan&#x27;, lastname: &#x27;Baker&#x27; }
);
// Using a predicate Function
people.find(function(e) { return e.firstname === &#x27;Jane&#x27; });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gauss.TimeSeries" id="apidoc.module.gauss.TimeSeries">module gauss.TimeSeries</a></h1>


    <h2>
        <a href="#apidoc.element.gauss.TimeSeries.TimeSeries" id="apidoc.element.gauss.TimeSeries.TimeSeries">
        function <span class="apidocSignatureSpan">gauss.</span>TimeSeries
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TimeSeries = function (values) {
  &#x22;use strict&#x22;;
  var timeseries = (arguments.length === 2) ?
    Array.prototype.slice.call(arguments) :
    values;

  if (Array.prototype.slice.call(arguments).length === 0) {
    timeseries = [];
  }

  var result = function(value, callback) {
    if (callback) {
      return callback(value);
    }
    else {
      return value;
    }
  };

  Object.defineProperty(timeseries, &#x27;extend&#x27;, {
<span class="apidocCodeCommentSpan">    /**
     * Return a TimeSeries extended with named functions.
     * @param methods Object { &#x27;functionName&#x27;: function() {} }
     */
</span>    value: function(methods, callback) {
      Collection.extend.bind(this);
      return Collection.extend.apply(this, arguments);
    },
    writable: true,
    enumerable: false
  });

  timeseries.extend({
    byValue: function(a, b) {
      return ((a[1] &#x3c; b[1]) ? -1 : ((a[1] &#x3e; b[1]) ? 1 : 0));
    },
    byDate: function(a, b) {
      return ((a[0] &#x3c; b[0]) ? -1 : ((a[0] &#x3e; b[0]) ? 1 : 0));
    },
    times: function(callback) {
      var times = new Vector(Array.prototype.map.call(this, function(i) {
        return i[0];
      }));
      return result(times, callback);
    },
    values: function(callback) {
      var values = new Vector(Array.prototype.map.call(this, function(i) {
        return i[1];
      }));
      return result(values, callback);
    }
  });

  timeseries.extend({
    every: Collection.every,
    append: Collection.append
  });

  return timeseries;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

*Deprecated*

Perform time series analysis. TimeSeries currently accepts time in epoch milliseconds followed by a numeric value.

``` javascript
var gauss = require(&#x27;gauss&#x27;);
var set = new gauss.<span class="apidocCodeKeywordSpan">TimeSeries</span>([1315378833000, 3.5], [1315789015000, 7.826]);
```

#### TimeSeries.times

    .times(callback)

Returns a Vector of the times.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gauss.Vector" id="apidoc.module.gauss.Vector">module gauss.Vector</a></h1>


    <h2>
        <a href="#apidoc.element.gauss.Vector.Vector" id="apidoc.element.gauss.Vector.Vector">
        function <span class="apidocSignatureSpan">gauss.</span>Vector
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Vector = function (values) {
  &#x22;use strict&#x22;;
  var vector = Array.isArray(values) ?
    values :
    Array.prototype.slice.call(arguments);

  if (Array.prototype.slice.call(arguments).length === 0) {
    vector = [];
  }

  // Initialize vector cache
  var cache = {
    sum: 0.0,
    product: 1.0,
    variance: 0.0,
    sample: {
      variance: 0.0
    },
    values: Array.prototype.slice.call(vector)
  };

  cache.sync = function() {
    cache.values = Array.prototype.slice.call(vector);
  };

  // Sorting primatives
  var asc = function(a, b) {
    return a - b;
  };

  var extend = function(value, callback) {
    value = Array.isArray(value) ?
      new Vector(value) : value;
    if (callback) {
      return callback(value);
    }
    else {
      return value;
    }
  };

  var result = function(value, callback) {
    if (callback) {
      return callback(value);
    }
    else {
      return value;
    }
  };

  Object.defineProperty(vector, &#x27;extend&#x27;, {
<span class="apidocCodeCommentSpan">    /**
     * Return a Vector extended with named functions.
     * @param methods Object { &#x27;functionName&#x27;: function() {} }
     */
</span>    value: function(methods, callback) {
      Collection.extend.bind(this);
      return Collection.extend.apply(this, arguments);
    },
    writable: true,
    enumerable: false
  });

  vector.extend({
    indexOf: Collection.indexOf,
    indexBy: Collection.indexBy,
    indicesOf: function(element, callback) {
      return extend(Collection.indicesOf.apply(this, arguments), callback);
    },
    indicesBy: function(predicate, callback) {
      return extend(Collection.indicesBy.apply(this, arguments), callback);
    },
    lastIndexBy: function(predicate, callback) {
      return extend(Collection.lastIndexBy.apply(this, arguments), callback);
    },
    find: function(predicate, callback) {
      return extend(Collection.find.apply(this, arguments), callback);
    },
    findOne: function(predicate, callback) {
      return extend(Collection.findOne.apply(this, arguments), callback);
    },
    mode: function(callback) {
      return extend(Collection.mode.apply(this), callback);
    },
    frequency: Collection.frequency,
    distribution: Collection.distribution,
    append: Collection.append,
    equal: Collection.equal,
    clone: function(callback) {
      return extend(Collection.clone.apply(this), callback);
    },
    copy: function(callback) {
      return extend(Collection.copy.apply(this), callback);
    },
    toArray: Collection.toArray,
    /**
     * [Accessor methods]
     */
    concat: function() {
      var args = Array.prototype.slice.call(arguments);
      var end = args[args.length - 1];
      if (typeof end === &#x27;function&#x27;) {
        return extend(Collection.concat.apply(this, arguments), end);
      }
      else {
        return extend(Collection.concat.apply(this, arguments));
      }
    },
    slice: function(begin, end, callback) {
      return extend(Collection.slice.apply(this, arguments), callback);
    },
    split: function(predicate, callback) {
      return extend(Collection.split.apply(this, arguments), callback);
    },
    unique: function(callback) {
      return extend(Collection.unique.apply(this), callback);
    },
    /**
     * [Iteration methods]
     */
    filter: function(callback, next) {
      return extend(Collection.filter.apply(this, arguments), next);
    },
    every: Collection.every,
    map: function(callback, next) {
      return extend(Collection.map.apply(this, arguments), next);
    },
    some: Collection.some,
    reduce: function(callback, initialValue, next) {
      return extend(Collection.reduce.apply(this, arguments), next);
    },
    reduceRight: function(callback, initialValue, next) {
      return extend(Collection.reduceRight.apply(this, arguments), next);
    },
    union: function(that, callback) {
      return extend(Collection.union.apply(this, arguments), callback);
    },
    sum: function(callback) {
      var sum = 0.0;
      if (this.equal(cache.values) &#x26;&#x26; cache.sum !== 0.0) {
        sum = cache.sum;
      }
      else {
        for (var i = 0; i &#x3c; this.le ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Gauss requires support for ECMAScript 5 `Object.defineProperty`. Compatibility is listed [here](http://kangax.github.com/es5-compat
-table/). Download and include [gauss.min.js](https://raw.github.com/wayoutmind/gauss/master/gauss.min.js):

``` html
&#x3c;script src=&#x22;gauss.min.js&#x22; type=&#x22;text/javascript&#x22;&#x3e;&#x3c;/script&#x3e;
&#x3c;script type=&#x22;text/javascript&#x22; charset=&#x22;utf-8&#x22;&#x3e;
var Vector = gauss.Vector,
    TimeSeries = gauss.TimeSeries;
var set = new gauss.<span class="apidocCodeKeywordSpan">Vector</span>(5, 1, 3, 2, 21),
    numbers = new Vector([8, 6, 7, 5, 3, 0, 9]);
&#x3c;/script&#x3e;
```

The [Bower](http://bower.io/) package manager can also be used to install Gauss:

$ bower install gauss
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gauss.gauss" id="apidoc.module.gauss.gauss">module gauss.gauss</a></h1>


    <h2>
        <a href="#apidoc.element.gauss.gauss.Collection" id="apidoc.element.gauss.gauss.Collection">
        function <span class="apidocSignatureSpan">gauss.gauss.</span>Collection
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Collection = function (values) {
  &#x22;use strict&#x22;;
  var collection = Array.isArray(values) ?
    values :
    Array.prototype.slice.call(arguments);

  if (Array.prototype.slice.call(arguments).length === 0) {
    collection = [];
  }

  var result = function(value, callback) {
    if (callback) {
      return callback(value);
    }
    else {
      return value;
    }
  };

  Object.defineProperty(collection, &#x27;extend&#x27;, {
<span class="apidocCodeCommentSpan">    /**
     * Return a Collection extended with named functions.
     * @param methods Object { &#x27;functionName&#x27;: function() {} }
     */
</span>    value: function(methods, callback) {
      for (var method in methods) {
        Object.defineProperty(this, method, {
          value: methods[method],
          writable: true,
          enumerable: false
        });
      }
      return result(this, callback);
    },
    writable: true,
    enumerable: false
  });

  collection.extend({
    indexOf: function(element, callback) {
      var index = -1;
      for (var i = 0; i &#x3c; this.length; i++) {
        if (this[i] === element) {
          index = i;
          break;
        }
      }
      return result(index, callback);
    },
    /**
     * Returns the first index of an element that matches a condition.
     * @param predicate {Function}
     * @param callback {Function}
     */
    indexBy: function(predicate, callback) {
      var index = -1;
      for (var i = 0; i &#x3c; this.length; i++) {
        if (predicate(this[i])) {
          index = i;
          break;
        }
      }
      return result(index, callback);
    },
    /**
     * Returns the indices of all elements that match a value.
     * @param element {Object}
     * @param callback {Function}
     */
    indicesOf: function(element, callback) {
      var start = this.indexOf(element),
          end = this.lastIndexOf(element),
          indices = new Collection();
      if (start === end) {
        indices.push(start);
      }
      else {
        for (var i = start; i &#x3c;= end; i++) {
          if (this[i] === element) {
            indices.push(i);
          }
        }
      }
      return result(indices, callback);
    },
    /**
     * Returns all indices of an element that match a condition.
     * @param predicate {Function}
     * @param callback {Function}
     */
    indicesBy: function(predicate, callback) {
      var start = 0,
          end = this.length - 1,
          indices = new Collection();
      if (start === end) {
        indices.push(start);
      }
      else {
        for (var i = start; i &#x3c;= end; i++) {
          if (predicate(this[i])) {
            indices.push(i);
          }
        }
      }
      return result(indices, callback);
    },
    /**
     * Returns the last index of an element that matches a condition.
     * @param predicate {Function}
     * @param callback {Function}
     */
    lastIndexBy: function(predicate, callback) {
      var index = -1;
      for (var i = this.length - 1; i &#x3e;= 0; i--) {
        if (predicate(this[i])) {
          index = i;
          break;
        }
      }
      return result(index, callback);
    },
    /**
     * Returns all the elements that match a condition.
     * @param predicate {Function or Object}
     * @param callback {Function}
     */
    find: function(predicate, callback) {
      var results = new Collection(),
          comparator = function(e) { return e === true; };
      if (typeof predicate === &#x27;object&#x27;) {
        for (var i = 0; i &#x3c; this.length; i++) {
          var conditions = [];
          for (var key in predicate) {
            conditions.push(predicate[key] === this[i][key]);
          }
          if (conditions.every(comparator)) {
            results.push(this[i]);
          }
        }
      } else {
        for (var i = 0; i &#x3c; this.length; i++) {
          if (predicate(this[i])) {
            results.push(this[i]);
          }
        }
      }
      return result(results, callback);
    },
    /**
     * Returns the first element that matches a condition.
     * @param predicate {Function or Object}
     * @param callback {Function}
     */
    findOne: fun ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Collection.find

    .find(predicate, callback)

Returns all the elements that match a condition.

``` javascript
var people = new gauss.<span class="apidocCodeKeywordSpan">Collection</span>(
  { firstname: &#x27;John&#x27;, lastname: &#x27;Smith&#x27; },
  { firstname: &#x27;Jane&#x27;, lastname: &#x27;Doe&#x27; },
  { firstname: &#x27;Mike&#x27;, lastname: &#x27;Smith&#x27; },
  { firstname: &#x27;Susan&#x27;, lastname: &#x27;Baker&#x27; }
);
// Using a predicate Function
people.find(function(e) { return e.firstname === &#x27;Jane&#x27; });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gauss.gauss.TimeSeries" id="apidoc.element.gauss.gauss.TimeSeries">
        function <span class="apidocSignatureSpan">gauss.gauss.</span>TimeSeries
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TimeSeries = function (values) {
  &#x22;use strict&#x22;;
  var timeseries = (arguments.length === 2) ?
    Array.prototype.slice.call(arguments) :
    values;

  if (Array.prototype.slice.call(arguments).length === 0) {
    timeseries = [];
  }

  var result = function(value, callback) {
    if (callback) {
      return callback(value);
    }
    else {
      return value;
    }
  };

  Object.defineProperty(timeseries, &#x27;extend&#x27;, {
<span class="apidocCodeCommentSpan">    /**
     * Return a TimeSeries extended with named functions.
     * @param methods Object { &#x27;functionName&#x27;: function() {} }
     */
</span>    value: function(methods, callback) {
      Collection.extend.bind(this);
      return Collection.extend.apply(this, arguments);
    },
    writable: true,
    enumerable: false
  });

  timeseries.extend({
    byValue: function(a, b) {
      return ((a[1] &#x3c; b[1]) ? -1 : ((a[1] &#x3e; b[1]) ? 1 : 0));
    },
    byDate: function(a, b) {
      return ((a[0] &#x3c; b[0]) ? -1 : ((a[0] &#x3e; b[0]) ? 1 : 0));
    },
    times: function(callback) {
      var times = new Vector(Array.prototype.map.call(this, function(i) {
        return i[0];
      }));
      return result(times, callback);
    },
    values: function(callback) {
      var values = new Vector(Array.prototype.map.call(this, function(i) {
        return i[1];
      }));
      return result(values, callback);
    }
  });

  timeseries.extend({
    every: Collection.every,
    append: Collection.append
  });

  return timeseries;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

*Deprecated*

Perform time series analysis. TimeSeries currently accepts time in epoch milliseconds followed by a numeric value.

``` javascript
var gauss = require(&#x27;gauss&#x27;);
var set = new gauss.<span class="apidocCodeKeywordSpan">TimeSeries</span>([1315378833000, 3.5], [1315789015000, 7.826]);
```

#### TimeSeries.times

    .times(callback)

Returns a Vector of the times.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gauss.gauss.Vector" id="apidoc.element.gauss.gauss.Vector">
        function <span class="apidocSignatureSpan">gauss.gauss.</span>Vector
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Vector = function (values) {
  &#x22;use strict&#x22;;
  var vector = Array.isArray(values) ?
    values :
    Array.prototype.slice.call(arguments);

  if (Array.prototype.slice.call(arguments).length === 0) {
    vector = [];
  }

  // Initialize vector cache
  var cache = {
    sum: 0.0,
    product: 1.0,
    variance: 0.0,
    sample: {
      variance: 0.0
    },
    values: Array.prototype.slice.call(vector)
  };

  cache.sync = function() {
    cache.values = Array.prototype.slice.call(vector);
  };

  // Sorting primatives
  var asc = function(a, b) {
    return a - b;
  };

  var extend = function(value, callback) {
    value = Array.isArray(value) ?
      new Vector(value) : value;
    if (callback) {
      return callback(value);
    }
    else {
      return value;
    }
  };

  var result = function(value, callback) {
    if (callback) {
      return callback(value);
    }
    else {
      return value;
    }
  };

  Object.defineProperty(vector, &#x27;extend&#x27;, {
<span class="apidocCodeCommentSpan">    /**
     * Return a Vector extended with named functions.
     * @param methods Object { &#x27;functionName&#x27;: function() {} }
     */
</span>    value: function(methods, callback) {
      Collection.extend.bind(this);
      return Collection.extend.apply(this, arguments);
    },
    writable: true,
    enumerable: false
  });

  vector.extend({
    indexOf: Collection.indexOf,
    indexBy: Collection.indexBy,
    indicesOf: function(element, callback) {
      return extend(Collection.indicesOf.apply(this, arguments), callback);
    },
    indicesBy: function(predicate, callback) {
      return extend(Collection.indicesBy.apply(this, arguments), callback);
    },
    lastIndexBy: function(predicate, callback) {
      return extend(Collection.lastIndexBy.apply(this, arguments), callback);
    },
    find: function(predicate, callback) {
      return extend(Collection.find.apply(this, arguments), callback);
    },
    findOne: function(predicate, callback) {
      return extend(Collection.findOne.apply(this, arguments), callback);
    },
    mode: function(callback) {
      return extend(Collection.mode.apply(this), callback);
    },
    frequency: Collection.frequency,
    distribution: Collection.distribution,
    append: Collection.append,
    equal: Collection.equal,
    clone: function(callback) {
      return extend(Collection.clone.apply(this), callback);
    },
    copy: function(callback) {
      return extend(Collection.copy.apply(this), callback);
    },
    toArray: Collection.toArray,
    /**
     * [Accessor methods]
     */
    concat: function() {
      var args = Array.prototype.slice.call(arguments);
      var end = args[args.length - 1];
      if (typeof end === &#x27;function&#x27;) {
        return extend(Collection.concat.apply(this, arguments), end);
      }
      else {
        return extend(Collection.concat.apply(this, arguments));
      }
    },
    slice: function(begin, end, callback) {
      return extend(Collection.slice.apply(this, arguments), callback);
    },
    split: function(predicate, callback) {
      return extend(Collection.split.apply(this, arguments), callback);
    },
    unique: function(callback) {
      return extend(Collection.unique.apply(this), callback);
    },
    /**
     * [Iteration methods]
     */
    filter: function(callback, next) {
      return extend(Collection.filter.apply(this, arguments), next);
    },
    every: Collection.every,
    map: function(callback, next) {
      return extend(Collection.map.apply(this, arguments), next);
    },
    some: Collection.some,
    reduce: function(callback, initialValue, next) {
      return extend(Collection.reduce.apply(this, arguments), next);
    },
    reduceRight: function(callback, initialValue, next) {
      return extend(Collection.reduceRight.apply(this, arguments), next);
    },
    union: function(that, callback) {
      return extend(Collection.union.apply(this, arguments), callback);
    },
    sum: function(callback) {
      var sum = 0.0;
      if (this.equal(cache.values) &#x26;&#x26; cache.sum !== 0.0) {
        sum = cache.sum;
      }
      else {
        for (var i = 0; i &#x3c; this.le ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Gauss requires support for ECMAScript 5 `Object.defineProperty`. Compatibility is listed [here](http://kangax.github.com/es5-compat
-table/). Download and include [gauss.min.js](https://raw.github.com/wayoutmind/gauss/master/gauss.min.js):

``` html
&#x3c;script src=&#x22;gauss.min.js&#x22; type=&#x22;text/javascript&#x22;&#x3e;&#x3c;/script&#x3e;
&#x3c;script type=&#x22;text/javascript&#x22; charset=&#x22;utf-8&#x22;&#x3e;
var Vector = gauss.Vector,
    TimeSeries = gauss.TimeSeries;
var set = new gauss.<span class="apidocCodeKeywordSpan">Vector</span>(5, 1, 3, 2, 21),
    numbers = new Vector([8, 6, 7, 5, 3, 0, 9]);
&#x3c;/script&#x3e;
```

The [Bower](http://bower.io/) package manager can also be used to install Gauss:

$ bower install gauss
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
